@inject FhirResourceService FhirResourceService
@inject IJSRuntime JSRuntime
@using System.Text.Json
@using Ship.Ses.Extractor.UI.BlazorWeb.Models.ApiClient 
@using Ship.Ses.Extractor.UI.BlazorWeb.Models.UI

<div class="fhir-field-container">
    @if (_fhirLoading)
    {
        <div class="text-center p-3">
            <div class="spinner-border" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>
    }
    else if (_fields == null || !_fields.Any())
    {
        <div class="alert alert-info">
            No FHIR fields available. Please select a FHIR resource type.
        </div>
    }
    else
    {
        <div class="mb-3">
            <input type="text" class="form-control" placeholder="Search fields..."
                   @bind="_fhirSearchText" @bind:event="oninput" />
        </div>

        <div class="fhir-tree-view">
            @RenderFhirFields(_filteredFields, "")
        </div>
    }
</div>

@code {
    [Parameter]
    public int ResourceTypeId { get; set; }

    [Parameter]
    public EventCallback<MappingNode> OnFieldSelected { get; set; }

    private List<FhirFieldModel> _fields = new();
    private string _selectedFieldPath; // Visual selection in this component
    private bool _fhirLoading = true;
    private string _fhirSearchText = "";
    private HashSet<string> _expandedPaths = new();

    protected override async Task OnParametersSetAsync()
    {
        // Only reload fields if ResourceTypeId has changed and is valid
        if (ResourceTypeId > 0 && (_fields == null || !_fields.Any() || ResourceTypeId != _currentLoadedResourceTypeId))
        {
            await LoadFieldsAsync();
            _currentLoadedResourceTypeId = ResourceTypeId;
        }
        // If ResourceTypeId is reset or invalid, clear fields
        else if (ResourceTypeId <= 0 && (_fields != null && _fields.Any()))
        {
            _fields.Clear();
            _fhirLoading = false;
            _selectedFieldPath = null;
            _expandedPaths.Clear();
            _currentLoadedResourceTypeId = 0;
        }
    }

    private int _currentLoadedResourceTypeId; // Keep track of the last loaded ID

    private async Task LoadFieldsAsync()
    {
        _fhirLoading = true;
        _fields.Clear(); // Clear existing fields before loading
        _selectedFieldPath = null; // Clear selection
        _expandedPaths.Clear(); // Collapse all

        try
        {
            var jsonDocument = await FhirResourceService.GetResourceStructureAsync(ResourceTypeId);
            _fields = ParseFhirStructure(jsonDocument);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error loading FHIR fields: {ex.Message}");
            // Consider adding a UI alert here, passed as a parameter
        }
        finally
        {
            _fhirLoading = false;
        }
    }

    private List<FhirFieldModel> _filteredFields => string.IsNullOrWhiteSpace(_fhirSearchText)
        ? _fields
        : FilterFieldsBySearchText(_fields, _fhirSearchText);

    private List<FhirFieldModel> FilterFieldsBySearchText(List<FhirFieldModel> fields, string searchText)
    {
        var result = new List<FhirFieldModel>();

        foreach (var field in fields)
        {
            if (field.DisplayName.Contains(searchText, StringComparison.OrdinalIgnoreCase) ||
                field.Path.Contains(searchText, StringComparison.OrdinalIgnoreCase))
            {
                result.Add(field);
            }
            else if (field.Children.Any())
            {
                var filteredChildren = FilterFieldsBySearchText(field.Children, searchText);
                if (filteredChildren.Any())
                {
                    // Clone the parent and add filtered children
                    var clone = new FhirFieldModel
                        {
                            Path = field.Path,
                            DisplayName = field.DisplayName,
                            DataType = field.DataType,
                            IsRequired = field.IsRequired,
                            Children = filteredChildren,
                            TemplateName = field.TemplateName // Preserve TemplateName
                        };
                    result.Add(clone);
                }
            }
        }

        return result;
    }

    private RenderFragment RenderFhirFields(List<FhirFieldModel> fields, string parentPath) => builder =>
    {
        foreach (var field in fields)
        {
            builder.OpenElement(0, "div");
            builder.AddAttribute(1, "class", $"fhir-tree-item {(field.Path == _selectedFieldPath ? "selected" : "")}");

            builder.OpenElement(2, "div");
            builder.AddAttribute(3, "class", "fhir-tree-item-header");
            // The main header click selects the field
            builder.AddAttribute(4, "onclick", EventCallback.Factory.Create<MouseEventArgs>(this, () => SelectField(field)));

            // Toggle icon for expansion
            if (field.Children.Any())
            {
                builder.OpenElement(5, "span");
                builder.AddAttribute(6, "class", $"toggle-icon {(_expandedPaths.Contains(field.Path) ? "expanded" : "")}");
                // Add the Blazor stopPropagation directive here directly:
                builder.AddAttribute(7, "onclick:stopPropagation", "true"); // <-- This is the key change!

                builder.AddAttribute(8, "onclick", EventCallback.Factory.Create<MouseEventArgs>(this, (e) =>
                {
                    // REMOVE THE JSRuntime call here. It's no longer needed.
                    // await JSRuntime.InvokeVoidAsync("stopEventPropagation", e); // Delete this line
                    ToggleFieldExpand(field.Path);
                }));
                builder.OpenElement(8, "span");
                builder.AddAttribute(9, "class", $"oi {(_expandedPaths.Contains(field.Path) ? "oi-caret-bottom" : "oi-caret-right")}");
                builder.CloseElement();
                builder.CloseElement();
            }
            else
            {
                // Placeholder for alignment if no children
                builder.OpenElement(5, "span");
                builder.AddAttribute(6, "class", "toggle-icon placeholder");
                builder.CloseElement();
            }

            builder.OpenElement(10, "span");
            builder.AddAttribute(11, "class", "item-icon");
            if (field.IsRequired)
            {
                builder.OpenElement(12, "span");
                builder.AddAttribute(13, "class", "oi oi-asterisk");
                builder.AddAttribute(14, "title", "Required");
                builder.CloseElement();
            }
            else
            {
                builder.OpenElement(12, "span");
                builder.AddAttribute(13, "class", "oi oi-list");
                builder.CloseElement();
            }
            builder.CloseElement();

            builder.OpenElement(15, "span");
            builder.AddAttribute(16, "class", "item-label");
            builder.AddContent(17, field.DisplayName);
            builder.CloseElement();

            builder.OpenElement(18, "span");
            builder.AddAttribute(19, "class", "item-type");
            builder.AddContent(20, field.DataType);
            builder.CloseElement();

            builder.CloseElement(); // fhir-tree-item-header

            if (field.Children.Any() && _expandedPaths.Contains(field.Path))
            {
                builder.OpenElement(21, "div");
                builder.AddAttribute(22, "class", "fhir-tree-item-children");
                builder.AddContent(23, RenderFhirFields(field.Children, field.Path));
                builder.CloseElement();
            }

            builder.CloseElement(); // fhir-tree-item
        }
    };

    private async Task SelectField(FhirFieldModel field)
    {
        // If selecting an already selected field, de-select it
        if (_selectedFieldPath == field.Path)
        {
            _selectedFieldPath = null;
            await OnFieldSelected.InvokeAsync(null); // Notify parent of deselection
            return;
        }

        _selectedFieldPath = field.Path;

        // For "object" or "array" types, allow expansion without immediate selection for mapping
        if (field.Children.Any())
        {
            ToggleFieldExpand(field.Path);
            // Don't invoke OnFieldSelected for parent nodes directly, only leaf nodes.
            // However, if a user *explicitly clicks* a parent, they might want to map to it
            // as a complex type. This needs careful UX consideration.
            // For now, let's assume direct selection is for leaf nodes or complex objects meant as templates.

            // If the parent itself is a valid mapping target (e.g., Patient.name is a HumanName template)
            // then you can still fire OnFieldSelected.
            // For now, only fire for leaf nodes OR complex objects identified as templates
            // This is where 'TemplateName' property on FhirFieldModel would be useful
            if (!string.IsNullOrEmpty(field.TemplateName) || !field.Children.Any()) // Map only if it's a leaf or has a known template
            {
                var node = new MappingNode
                    {
                        Id = $"fhir-field-{field.Path.Replace('.', '-')}",
                        Label = field.DisplayName,
                        Type = "FHIR",
                        Path = field.Path,
                        DataType = field.DataType,
                        IsRequired = field.IsRequired,
                        IsSelected = true
                    };
                await OnFieldSelected.InvokeAsync(node);
            }
            else // It's an object/array without a template defined, just expand
            {
                // Do nothing, just expand
            }
        }
        else // It's a leaf node (no children)
        {
            // Notify parent for leaf nodes
            var node = new MappingNode
                {
                    Id = $"fhir-field-{field.Path.Replace('.', '-')}",
                    Label = field.DisplayName,
                    Type = "FHIR",
                    Path = field.Path,
                    DataType = field.DataType,
                    IsRequired = field.IsRequired,
                    IsSelected = true
                };
            await OnFieldSelected.InvokeAsync(node);
        }
    }

    private void ToggleFieldExpand(string path)
    {
        if (_expandedPaths.Contains(path))
        {
            _expandedPaths.Remove(path);
        }
        else
        {
            _expandedPaths.Add(path);
        }
    }

    // This is a simplified version - in a real app you would parse the JSON structure more carefully
    private List<FhirFieldModel> ParseFhirStructure(JsonDocument jsonDoc)
    {
        try
        {
            var fields = new List<FhirFieldModel>();
            var root = jsonDoc.RootElement;

            foreach (var property in root.EnumerateObject())
            {
                if (property.Name == "resourceType")
                    continue;

                var field = ParseJsonProperty(property, "");
                fields.Add(field);
            }

            return fields;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error parsing FHIR structure: {ex.Message}");
            return new List<FhirFieldModel>();
        }
    }

    private FhirFieldModel ParseJsonProperty(JsonProperty property, string parentPath)
    {
        var path = string.IsNullOrEmpty(parentPath) ? property.Name : $"{parentPath}.{property.Name}";
        var field = new FhirFieldModel
            {
                Path = path,
                DisplayName = property.Name,
                IsRequired = false // Default, would need resource-specific logic to determine
            };

        // Attempt to infer TemplateName based on common FHIR types or your custom logic
        field.TemplateName = InferFhirTemplate(property.Name, property.Value.ValueKind);

        switch (property.Value.ValueKind)
        {
            case JsonValueKind.Object:
                field.DataType = "Object";
                foreach (var childProp in property.Value.EnumerateObject())
                {
                    field.Children.Add(ParseJsonProperty(childProp, path));
                }
                break;

            case JsonValueKind.Array:
                field.DataType = "Array";
                // For arrays, if the first element is an object, we want to represent its structure.
                if (property.Value.GetArrayLength() > 0)
                {
                    var firstElement = property.Value.EnumerateArray().FirstOrDefault();
                    if (firstElement.ValueKind == JsonValueKind.Object)
                    {
                        // --- THIS IS THE CRUCIAL CHANGE ---
                        // Instead of creating a dummy JsonProperty, we directly enumerate the properties
                        // of the 'firstElement' (which is a JsonElement representing an object)
                        foreach (var childPropInArray in firstElement.EnumerateObject()) // Iterate properties of the object inside the array
                        {
                            // The path for children of an array item should include the array index, e.g., "name[0].given"
                            // So, we pass the updated parentPath for the recursive call.
                            field.Children.Add(ParseJsonProperty(childPropInArray, $"{path}[0]"));
                        }
                        // Update display type for arrays of objects
                        field.DataType = $"Array<{field.DisplayName.TrimEnd('s')}>"; // e.g., "Array<Name>", "Array<Contact>"
                        field.TemplateName = InferFhirTemplate(property.Name, JsonValueKind.Array); // E.g., for "name" array
                    }
                    else
                    {
                        // If array contains primitives (e.g., array of strings or numbers)
                        // We can still try to infer type or just set a generic array type.
                        // For now, let's keep it simple for primitive arrays.
                        field.DataType = $"Array<{firstElement.ValueKind.ToString()}>";
                    }
                }
                break;

            case JsonValueKind.String:
                field.DataType = "String";
                break;

            case JsonValueKind.Number:
                field.DataType = "Number";
                break;

            case JsonValueKind.True:
            case JsonValueKind.False:
                field.DataType = "Boolean";
                break;

            default:
                field.DataType = property.Value.ValueKind.ToString();
                break;
        }

        return field;
    }

    // Helper to infer FHIR template names based on property name and type
    private string InferFhirTemplate(string propertyName, JsonValueKind valueKind)
    {
        // Common FHIR complex types that often appear as templates
        return propertyName.ToLower() switch
        {
            "name" when valueKind == JsonValueKind.Array => "HumanName",
            "telecom" when valueKind == JsonValueKind.Array => "ContactPoint",
            "address" when valueKind == JsonValueKind.Array => "Address",
            "identifier" when valueKind == JsonValueKind.Array => "Identifier",
            "coding" when valueKind == JsonValueKind.Array => "Coding", // Often part of CodeableConcept
            "code" when valueKind == JsonValueKind.Object => "CodeableConcept", // Assuming a CodeableConcept
            "maritalstatus" => "CodeableConcept", // Specific case from your JSON
            "contact" when valueKind == JsonValueKind.Array => "Contact", // Patient.contact
            "managingorganization" => "Reference", // FHIR Reference type
            _ => null
        };
    }
}